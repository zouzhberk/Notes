<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>JDK8-and-functional-program</title>
		<style>
			body {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
h1, h2, h3 {
	font-weight: 400;
	margin-bottom: 0;
}
.remark-slide-content h1 { font-size: 3em; }
.remark-slide-content h2 { font-size: 2em; }
.remark-slide-content h3 { font-size: 1.6em; }
.footnote {
	position: absolute;
	bottom: 1em;
	/*bottom: 3em;*/
}
li p { line-height: 1.25em; }
.red { color: #fa0000; }
.large { font-size: 2em; }
a, a > code {
	color: rgb(249, 38, 114);
	text-decoration: none;
}
code {
	background: none repeat scroll 0 0 #F8F8FF;
  border: 1px solid #DEDEDE;
  border-radius: 3px 	;
  padding: 0 0.2em;
}
.remark-code, .remark-inline-code { font-family: "Bitstream Vera Sans Mono", "Courier", monospace; }
.remark-code-line-highlighted     { background-color: #373832; }
.pull-left {
	float: left;
	width: 47%;
}
.pull-right {
	float: right;
	width: 47%;
}
.pull-right ~ p {
	clear: both;
}
#slideshow .slide .content code {
	font-size: 0.8em;
}
#slideshow .slide .content pre code {
	font-size: 0.9em;
	padding: 10px;
/*	#padding: 15px; */
}
.main-title, .title {
	background: #272822;
	color: #777872;
	text-shadow: 0 0 20px #333;
}
.title h1, .title h2, .main-title h1, .main-title h2 {
	color: #f3f3f3;
	line-height: 0.8em;
}
/* Custom */
.remark-code {
	display: block;
	padding: 0.5em;
}

		</style>
	</head>
	<body>
		<textarea id="source">
class: center, middle, inverse

# JDK8 中的函数式编程

### Berk
### 9/23/2015




---

class: center, middle, inverse

## JDK8 中的函数式编程


---

### Lambda 表达式


```java
//Consumer使用 @FunctionalInterface 明确声明接口作为函数式接口.
Consumer<String> consumer1 = new Consumer<String>()
{
    public void accept(final String name)
    {
        System.out.println(name);
    }
};

Consumer<String> consumer2 = (final String name) -> System.out
        .println(name);

Consumer<String> consumer3 = (name) -> System.out.println(name);

Consumer<String> consumer4 = name -> System.out.println(name);

Consumer<String> consumer5 = System.out::println;

Stream.of("hello", "world").forEach(consumer1);
Stream.of("hello", "world").forEach(consumer2);
Stream.of("hello", "world").forEach(consumer3);
Stream.of("hello", "world").forEach(consumer4);
Stream.of("hello", "world").forEach(consumer5);

```

---

### 方法引用(Method Reference)

- 构造器引用 （Class< T >::new）
- 静态方法引用 （Class::static_method）
- 特定类的任意对象的方法引用（Class::method）
- 特定对象的方法引用（instance::method）


```java

final List<Integer> words = IntStream.range('A', 'z')
        .mapToObj(Integer::new)
        .collect(Collectors.toList());

//Without method reference
BigDecimal bigDecimal = Stream.of("hello", "world", "!")
        .flatMapToInt((s) -> s.chars())
        .filter((s) -> words.contains(s))
        .mapToObj((s) -> String.valueOf(s))
        .map((s) -> new BigDecimal(s))
        .reduce(new BigDecimal(1), (x, y) -> x.add(y));

//With method reference
BigDecimal ret = Stream.of("hello", "world", "!")
        .flatMapToInt(String::chars) //Class::method
        .filter(words::contains)  //instance::method
        .mapToObj(String::valueOf) //Class::static_method
        .map(BigDecimal::new) // Class< T >::new
        .reduce(new BigDecimal(1), BigDecimal::add);
```


---

### 使用集合(1)


- 迭代(forEach)

```java
final List<String> friends = Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");
//Old way.
for (String friend : friends)
{
    System.out.println(friend);
}
//New way.
friends.forEach(name -> System.out.println(name));

```

- 转换 (map)

```java
//Old way.
List<String> uppercaseNames = new ArrayList<String>();
for (String name : friends)
{
    uppercaseNames.add(name.toUpperCase());
}
System.out.println(uppercaseNames);
//New way.
uppercaseNames = friends.stream().map(String::toUpperCase)
                        .collect(Collectors.toList());
System.out.println(uppercaseNames);

```
---

### 使用集合(2)

- 筛选(filter)

```java
//Old way.
for (String name : friends){
    if (name.contains("r") && name.contains("a")) 
        System.out.println(name);    
}
//New way.
friends.stream().filter((s) -> s.contains("r"))
       .filter((s) -> s.contains("a")).forEach(System.out::println);
```

- 元素选取(findFirst/findAny)

```java
//Old way
String foundName = null;
for (String name : friends){
    if (name.startsWith("N")){
        foundName = name;
        break;
    }
}
if (foundName == null) throw new NoSuchElementException("no name found.");
System.out.println(foundName);
//New way.
friends.stream().filter((s) -> s.startsWith("N")).findFirst()
       .ifPresent(System.out::println);
```

---

### 使用集合(3)

- 聚合操作

---

### String 处理

---

### 使用资源

---

### Being Lazy

---

## 函数式编程基本原则

### 避免可变状态

### 函数是第一类值（Functions as First-Class Values）
意味着函数可以像参数一样传输可以返回



---


# 附录：

## JDK 8 语言新特性

- Lambda表达式与Functional接口

'''

'''

>为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）

- 接口的默认方法与静态方法


- 方法引用
  - 构造器引用 （Class< T >::new）
  - 静态方法引用 （Class::static_method）
  - 特定类的任意对象的方法引用（Class::method）
  - 特定对象的方法引用（instance::method）

- 注解功能扩展
  - 重复注解：通过@Repeatable注解目标注解，目标注解可以重复注解；
  - 扩展注解的支持：任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。

- 更好的类型推测机制

---

## JDK 8类库的新特新

### Optional

### Stream API

### Date/Time API

- 不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。

- 关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。

- 清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。

- 实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。

- 可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。


>> http://www.codeceo.com/article/java-8-date-time-api.html

### JavaScript引擎Nashorn

### 其它
Files 
Base64

---

# Java8中的函数编程思维

一种编程范式

## 函数式编程基本原则

### 避免可变状态

### 函数是第一类值（Functions as First-Class Values）
意味着函数可以像参数一样传输可以返回



### 支持懒惰计算（lazy evaluation）；

### 使用递归作为控制流程的机制；

### 加强了引用透明性；

### 没有副作用（Side-Effect）；




### 表达式与变换
函数式编程将程序表达为表达式与变换，以数学方程形式建立模型，并尽量避免可变状态，其中三个主要变换为：

'''

逻辑 --> 变换

'''

- Filter(筛选)


- Map（映射）


- Fold/Reduce(折叠/化约)：都是通过一个累积量来收集集合元素


### 高阶函数与闭包(Higher-order function & Closure)





expression and transform
---

## Reference

[1] [Java8新特性](http://www.importnew.com/11908.html#NewFeatureOfLanguage)

[2] [What's New in JDK 8](http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html)

[3] [Java 8 日期/时间（Date Time）API指南](http://www.codeceo.com/article/java-8-date-time-api.html)

http://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html

http://rogachev.dlinkddns.com:8080/Copy/Computing/functional_programming_for_java_developers.pdf

http://cfile28.uf.tistory.com/attach/250C874B52DCD4A20F56B7

		</textarea>
		<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
		<script>
			var slideshow = remark.create();
		</script>
		<script></script>
	</body>
</html>
